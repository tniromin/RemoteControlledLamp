
Lamp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  00000a24  00000ab8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000a24  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000013  00800102  00800102  00000aba  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000aba  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000aec  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000c0  00000000  00000000  00000b2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000f2c  00000000  00000000  00000bec  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008c2  00000000  00000000  00001b18  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000a82  00000000  00000000  000023da  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000214  00000000  00000000  00002e5c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000656  00000000  00000000  00003070  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000091c  00000000  00000000  000036c6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b0  00000000  00000000  00003fe2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3c 00 	jmp	0x78	; 0x78 <__ctors_end>
   4:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
   8:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
   c:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  10:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  14:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  18:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  1c:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  20:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  24:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  28:	0c 94 27 01 	jmp	0x24e	; 0x24e <__vector_10>
  2c:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  30:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  34:	0c 94 7d 02 	jmp	0x4fa	; 0x4fa <__vector_13>
  38:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  3c:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  40:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  44:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  48:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  4c:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  50:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  54:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  58:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  5c:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  60:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  64:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  68:	c0 02       	muls	r28, r16
  6a:	c6 02       	muls	r28, r22
  6c:	d3 02       	muls	r29, r19
  6e:	e6 02       	muls	r30, r22
  70:	ff 02       	muls	r31, r31
  72:	25 03       	mulsu	r18, r21
  74:	3d 03       	fmul	r19, r21
  76:	55 03       	mulsu	r21, r21

00000078 <__ctors_end>:
  78:	11 24       	eor	r1, r1
  7a:	1f be       	out	0x3f, r1	; 63
  7c:	cf ef       	ldi	r28, 0xFF	; 255
  7e:	d8 e0       	ldi	r29, 0x08	; 8
  80:	de bf       	out	0x3e, r29	; 62
  82:	cd bf       	out	0x3d, r28	; 61

00000084 <__do_copy_data>:
  84:	11 e0       	ldi	r17, 0x01	; 1
  86:	a0 e0       	ldi	r26, 0x00	; 0
  88:	b1 e0       	ldi	r27, 0x01	; 1
  8a:	e4 e2       	ldi	r30, 0x24	; 36
  8c:	fa e0       	ldi	r31, 0x0A	; 10
  8e:	02 c0       	rjmp	.+4      	; 0x94 <__do_copy_data+0x10>
  90:	05 90       	lpm	r0, Z+
  92:	0d 92       	st	X+, r0
  94:	a2 30       	cpi	r26, 0x02	; 2
  96:	b1 07       	cpc	r27, r17
  98:	d9 f7       	brne	.-10     	; 0x90 <__do_copy_data+0xc>

0000009a <__do_clear_bss>:
  9a:	21 e0       	ldi	r18, 0x01	; 1
  9c:	a2 e0       	ldi	r26, 0x02	; 2
  9e:	b1 e0       	ldi	r27, 0x01	; 1
  a0:	01 c0       	rjmp	.+2      	; 0xa4 <.do_clear_bss_start>

000000a2 <.do_clear_bss_loop>:
  a2:	1d 92       	st	X+, r1

000000a4 <.do_clear_bss_start>:
  a4:	a5 31       	cpi	r26, 0x15	; 21
  a6:	b2 07       	cpc	r27, r18
  a8:	e1 f7       	brne	.-8      	; 0xa2 <.do_clear_bss_loop>
  aa:	0e 94 ba 03 	call	0x774	; 0x774 <main>
  ae:	0c 94 10 05 	jmp	0xa20	; 0xa20 <_exit>

000000b2 <__bad_interrupt>:
  b2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b6 <IR_resetRX>:
/*-----------------------------------------------------------------------------
	Disable the Timer and associated interrupts.
------------------------------------------------------------------------------*/
void IR_disable(void){
	TIMSKn = 0;
	TCCRnB = 0;
  b6:	10 92 11 01 	sts	0x0111, r1	; 0x800111 <IR_dataRX>
  ba:	10 92 12 01 	sts	0x0112, r1	; 0x800112 <IR_dataRX+0x1>
  be:	10 92 13 01 	sts	0x0113, r1	; 0x800113 <IR_dataRX+0x2>
  c2:	10 92 14 01 	sts	0x0114, r1	; 0x800114 <IR_dataRX+0x3>
  c6:	10 92 0a 01 	sts	0x010A, r1	; 0x80010a <IR_RXexpectedBits>
  ca:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <IR_waitNextPulse>
  ce:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <IR_stageRX>
  d2:	08 95       	ret

000000d4 <IR_init>:
  d4:	84 b1       	in	r24, 0x04	; 4
  d6:	8e 7f       	andi	r24, 0xFE	; 254
  d8:	84 b9       	out	0x04, r24	; 4
  da:	85 b1       	in	r24, 0x05	; 5
  dc:	8d 7f       	andi	r24, 0xFD	; 253
  de:	85 b9       	out	0x05, r24	; 5
  e0:	84 b1       	in	r24, 0x04	; 4
  e2:	82 60       	ori	r24, 0x02	; 2
  e4:	84 b9       	out	0x04, r24	; 4
  e6:	e1 e8       	ldi	r30, 0x81	; 129
  e8:	f0 e0       	ldi	r31, 0x00	; 0
  ea:	80 e8       	ldi	r24, 0x80	; 128
  ec:	80 83       	st	Z, r24
  ee:	80 81       	ld	r24, Z
  f0:	83 60       	ori	r24, 0x03	; 3
  f2:	80 83       	st	Z, r24
  f4:	81 e2       	ldi	r24, 0x21	; 33
  f6:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7f806f>
  fa:	78 94       	sei
  fc:	08 95       	ret

000000fe <IR_codeAvailable>:
  fe:	cf 93       	push	r28
 100:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <IR_protocolType>
 104:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <IR_protocolTypeExt>
 108:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <IR_stageRX>
 10c:	99 30       	cpi	r25, 0x09	; 9
 10e:	09 f0       	breq	.+2      	; 0x112 <IR_codeAvailable+0x14>
 110:	7a c0       	rjmp	.+244    	; 0x206 <IR_codeAvailable+0x108>
 112:	81 30       	cpi	r24, 0x01	; 1
 114:	89 f5       	brne	.+98     	; 0x178 <IR_codeAvailable+0x7a>
 116:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <IR_dataRX>
 11a:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <IR_dataRX+0x1>
 11e:	a0 91 13 01 	lds	r26, 0x0113	; 0x800113 <IR_dataRX+0x2>
 122:	b0 91 14 01 	lds	r27, 0x0114	; 0x800114 <IR_dataRX+0x3>
 126:	00 97       	sbiw	r24, 0x00	; 0
 128:	a1 05       	cpc	r26, r1
 12a:	b1 05       	cpc	r27, r1
 12c:	09 f4       	brne	.+2      	; 0x130 <IR_codeAvailable+0x32>
 12e:	5f c0       	rjmp	.+190    	; 0x1ee <IR_codeAvailable+0xf0>
 130:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <IR_address+0x1>
 134:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <IR_address>
 138:	4a 2f       	mov	r20, r26
 13a:	50 e0       	ldi	r21, 0x00	; 0
 13c:	50 93 0e 01 	sts	0x010E, r21	; 0x80010e <IR_command+0x1>
 140:	40 93 0d 01 	sts	0x010D, r20	; 0x80010d <IR_command>
 144:	2b 2f       	mov	r18, r27
 146:	20 95       	com	r18
 148:	bc 01       	movw	r22, r24
 14a:	77 27       	eor	r23, r23
 14c:	88 27       	eor	r24, r24
 14e:	80 95       	com	r24
 150:	90 95       	com	r25
 152:	68 17       	cp	r22, r24
 154:	79 07       	cpc	r23, r25
 156:	29 f4       	brne	.+10     	; 0x162 <IR_codeAvailable+0x64>
 158:	70 93 10 01 	sts	0x0110, r23	; 0x800110 <IR_address+0x1>
 15c:	60 93 0f 01 	sts	0x010F, r22	; 0x80010f <IR_address>
 160:	03 c0       	rjmp	.+6      	; 0x168 <IR_codeAvailable+0x6a>
 162:	82 e0       	ldi	r24, 0x02	; 2
 164:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <IR_protocolTypeExt>
 168:	82 2f       	mov	r24, r18
 16a:	90 e0       	ldi	r25, 0x00	; 0
 16c:	48 17       	cp	r20, r24
 16e:	59 07       	cpc	r21, r25
 170:	09 f4       	brne	.+2      	; 0x174 <IR_codeAvailable+0x76>
 172:	3f c0       	rjmp	.+126    	; 0x1f2 <IR_codeAvailable+0xf4>
 174:	c0 e0       	ldi	r28, 0x00	; 0
 176:	42 c0       	rjmp	.+132    	; 0x1fc <IR_codeAvailable+0xfe>
 178:	83 30       	cpi	r24, 0x03	; 3
 17a:	e9 f5       	brne	.+122    	; 0x1f6 <IR_codeAvailable+0xf8>
 17c:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <IR_dataRX>
 180:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <IR_dataRX+0x1>
 184:	a0 91 13 01 	lds	r26, 0x0113	; 0x800113 <IR_dataRX+0x2>
 188:	b0 91 14 01 	lds	r27, 0x0114	; 0x800114 <IR_dataRX+0x3>
 18c:	ac 01       	movw	r20, r24
 18e:	bd 01       	movw	r22, r26
 190:	68 94       	set
 192:	15 f8       	bld	r1, 5
 194:	76 95       	lsr	r23
 196:	67 95       	ror	r22
 198:	57 95       	ror	r21
 19a:	47 95       	ror	r20
 19c:	16 94       	lsr	r1
 19e:	d1 f7       	brne	.-12     	; 0x194 <IR_codeAvailable+0x96>
 1a0:	4f 71       	andi	r20, 0x1F	; 31
 1a2:	55 27       	eor	r21, r21
 1a4:	50 93 10 01 	sts	0x0110, r21	; 0x800110 <IR_address+0x1>
 1a8:	40 93 0f 01 	sts	0x010F, r20	; 0x80010f <IR_address>
 1ac:	9c 01       	movw	r18, r24
 1ae:	2f 73       	andi	r18, 0x3F	; 63
 1b0:	33 27       	eor	r19, r19
 1b2:	30 93 0e 01 	sts	0x010E, r19	; 0x80010e <IR_command+0x1>
 1b6:	20 93 0d 01 	sts	0x010D, r18	; 0x80010d <IR_command>
 1ba:	ac 01       	movw	r20, r24
 1bc:	bd 01       	movw	r22, r26
 1be:	03 2e       	mov	r0, r19
 1c0:	3b e0       	ldi	r19, 0x0B	; 11
 1c2:	76 95       	lsr	r23
 1c4:	67 95       	ror	r22
 1c6:	57 95       	ror	r21
 1c8:	47 95       	ror	r20
 1ca:	3a 95       	dec	r19
 1cc:	d1 f7       	brne	.-12     	; 0x1c2 <IR_codeAvailable+0xc4>
 1ce:	30 2d       	mov	r19, r0
 1d0:	41 70       	andi	r20, 0x01	; 1
 1d2:	40 93 08 01 	sts	0x0108, r20	; 0x800108 <IR_ToggleBit>
 1d6:	94 fd       	sbrc	r25, 4
 1d8:	10 c0       	rjmp	.+32     	; 0x1fa <IR_codeAvailable+0xfc>
 1da:	84 e0       	ldi	r24, 0x04	; 4
 1dc:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <IR_protocolTypeExt>
 1e0:	20 64       	ori	r18, 0x40	; 64
 1e2:	30 93 0e 01 	sts	0x010E, r19	; 0x80010e <IR_command+0x1>
 1e6:	20 93 0d 01 	sts	0x010D, r18	; 0x80010d <IR_command>
 1ea:	c1 e0       	ldi	r28, 0x01	; 1
 1ec:	07 c0       	rjmp	.+14     	; 0x1fc <IR_codeAvailable+0xfe>
 1ee:	c1 e0       	ldi	r28, 0x01	; 1
 1f0:	05 c0       	rjmp	.+10     	; 0x1fc <IR_codeAvailable+0xfe>
 1f2:	c1 e0       	ldi	r28, 0x01	; 1
 1f4:	03 c0       	rjmp	.+6      	; 0x1fc <IR_codeAvailable+0xfe>
 1f6:	c0 e0       	ldi	r28, 0x00	; 0
 1f8:	01 c0       	rjmp	.+2      	; 0x1fc <IR_codeAvailable+0xfe>
 1fa:	c1 e0       	ldi	r28, 0x01	; 1
 1fc:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <IR_stageRX>
 200:	0e 94 5b 00 	call	0xb6	; 0xb6 <IR_resetRX>
 204:	01 c0       	rjmp	.+2      	; 0x208 <IR_codeAvailable+0x10a>
 206:	c0 e0       	ldi	r28, 0x00	; 0
 208:	cc 23       	and	r28, r28
 20a:	11 f0       	breq	.+4      	; 0x210 <IR_codeAvailable+0x112>
 20c:	81 e0       	ldi	r24, 0x01	; 1
 20e:	01 c0       	rjmp	.+2      	; 0x212 <IR_codeAvailable+0x114>
 210:	80 e0       	ldi	r24, 0x00	; 0
 212:	cf 91       	pop	r28
 214:	08 95       	ret

00000216 <IR_getCode>:
 216:	20 91 0f 01 	lds	r18, 0x010F	; 0x80010f <IR_address>
 21a:	30 91 10 01 	lds	r19, 0x0110	; 0x800110 <IR_address+0x1>
 21e:	fc 01       	movw	r30, r24
 220:	31 83       	std	Z+1, r19	; 0x01
 222:	20 83       	st	Z, r18
 224:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <IR_command>
 228:	90 91 0e 01 	lds	r25, 0x010E	; 0x80010e <IR_command+0x1>
 22c:	fb 01       	movw	r30, r22
 22e:	91 83       	std	Z+1, r25	; 0x01
 230:	80 83       	st	Z, r24
 232:	10 92 0e 01 	sts	0x010E, r1	; 0x80010e <IR_command+0x1>
 236:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <IR_command>
 23a:	10 92 10 01 	sts	0x0110, r1	; 0x800110 <IR_address+0x1>
 23e:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <IR_address>
 242:	08 95       	ret

00000244 <IR_isRepeatCode>:
 244:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <IR_RepeatCode>
 248:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <IR_RepeatCode>
 24c:	08 95       	ret

0000024e <__vector_10>:
	The protocol type is defined here but not the extended ones. 
	If the protocol is extended is decided in the decoder function.
	This ISR triggers on every pulse then the pulses are converted to bits
	that are stored in a 32-bit variable used by the decoder function.
------------------------------------------------------------------------------*/
ISR(TIMERn_CAPT_vect){
 24e:	1f 92       	push	r1
 250:	0f 92       	push	r0
 252:	0f b6       	in	r0, 0x3f	; 63
 254:	0f 92       	push	r0
 256:	11 24       	eor	r1, r1
 258:	ef 92       	push	r14
 25a:	ff 92       	push	r15
 25c:	0f 93       	push	r16
 25e:	1f 93       	push	r17
 260:	2f 93       	push	r18
 262:	3f 93       	push	r19
 264:	4f 93       	push	r20
 266:	5f 93       	push	r21
 268:	6f 93       	push	r22
 26a:	7f 93       	push	r23
 26c:	8f 93       	push	r24
 26e:	9f 93       	push	r25
 270:	af 93       	push	r26
 272:	bf 93       	push	r27
 274:	cf 93       	push	r28
 276:	ef 93       	push	r30
 278:	ff 93       	push	r31
	uint16_t pulse_length;
	uint16_t IR_TimestampPrev;
	uint8_t pulse_level;
	
	if(IR_stageRX == IR_STAGE_END) return;
 27a:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <IR_stageRX>
 27e:	89 30       	cpi	r24, 0x09	; 9
 280:	09 f4       	brne	.+2      	; 0x284 <__vector_10+0x36>
 282:	25 c1       	rjmp	.+586    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
	
	// Save previous timestamp
	IR_TimestampPrev = IR_Timestamp;
 284:	20 91 04 01 	lds	r18, 0x0104	; 0x800104 <IR_Timestamp>
 288:	30 91 05 01 	lds	r19, 0x0105	; 0x800105 <IR_Timestamp+0x1>

	// Read TCNT1 timestamp
	IR_Timestamp = ICRn;
 28c:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
 290:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
 294:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <IR_Timestamp+0x1>
 298:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <IR_Timestamp>
	
	// Select the opposite edge to trigger
	TCCRnB ^= (1 << ICESn);
 29c:	e1 e8       	ldi	r30, 0x81	; 129
 29e:	f0 e0       	ldi	r31, 0x00	; 0
 2a0:	90 81       	ld	r25, Z
 2a2:	80 e4       	ldi	r24, 0x40	; 64
 2a4:	89 27       	eor	r24, r25
 2a6:	80 83       	st	Z, r24
	pulse_level = TCCRnB & (1<<ICESn);
 2a8:	c0 81       	ld	r28, Z
 2aa:	c0 74       	andi	r28, 0x40	; 64
	
	// Calculate time difference in timer ticks
	if(IR_TimerOverflows){
 2ac:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <IR_TimerOverflows>
 2b0:	88 23       	and	r24, r24
 2b2:	59 f0       	breq	.+22     	; 0x2ca <__vector_10+0x7c>
		pulse_length = (65535 - IR_TimestampPrev) + IR_Timestamp;
 2b4:	60 91 04 01 	lds	r22, 0x0104	; 0x800104 <IR_Timestamp>
 2b8:	70 91 05 01 	lds	r23, 0x0105	; 0x800105 <IR_Timestamp+0x1>
 2bc:	62 1b       	sub	r22, r18
 2be:	73 0b       	sbc	r23, r19
 2c0:	61 50       	subi	r22, 0x01	; 1
 2c2:	71 09       	sbc	r23, r1
		IR_TimerOverflows = 0;
 2c4:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <IR_TimerOverflows>
 2c8:	06 c0       	rjmp	.+12     	; 0x2d6 <__vector_10+0x88>
	}else{
		pulse_length = IR_Timestamp - IR_TimestampPrev;
 2ca:	60 91 04 01 	lds	r22, 0x0104	; 0x800104 <IR_Timestamp>
 2ce:	70 91 05 01 	lds	r23, 0x0105	; 0x800105 <IR_Timestamp+0x1>
 2d2:	62 1b       	sub	r22, r18
 2d4:	73 0b       	sbc	r23, r19
	}
	
	pulse_length = pulse_length * IR_TICK_TIME;
 2d6:	80 e0       	ldi	r24, 0x00	; 0
 2d8:	90 e0       	ldi	r25, 0x00	; 0
 2da:	0e 94 0f 04 	call	0x81e	; 0x81e <__floatunsisf>
 2de:	2d eb       	ldi	r18, 0xBD	; 189
 2e0:	37 e3       	ldi	r19, 0x37	; 55
 2e2:	46 e8       	ldi	r20, 0x86	; 134
 2e4:	56 e3       	ldi	r21, 0x36	; 54
 2e6:	0e 94 75 04 	call	0x8ea	; 0x8ea <__mulsf3>
 2ea:	20 e0       	ldi	r18, 0x00	; 0
 2ec:	34 e2       	ldi	r19, 0x24	; 36
 2ee:	44 e7       	ldi	r20, 0x74	; 116
 2f0:	59 e4       	ldi	r21, 0x49	; 73
 2f2:	0e 94 75 04 	call	0x8ea	; 0x8ea <__mulsf3>
 2f6:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <__fixunssfsi>
 2fa:	9b 01       	movw	r18, r22
	
	// Reset protocol and decoding after long idle period
	// Depending on the protocol used, this can also hold half of start bit
	if(pulse_length > 15000){
 2fc:	69 39       	cpi	r22, 0x99	; 153
 2fe:	0a e3       	ldi	r16, 0x3A	; 58
 300:	70 07       	cpc	r23, r16
 302:	18 f0       	brcs	.+6      	; 0x30a <__vector_10+0xbc>
		// This prevents collecting data in the middle of the frame
		IR_frameStart = true;
		IR_resetRX();
 304:	0e 94 5b 00 	call	0xb6	; 0xb6 <IR_resetRX>
		return;
 308:	e2 c0       	rjmp	.+452    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
	}
	
	
	// Detect protocol type by checking leader code
	switch(IR_stageRX){
 30a:	40 91 09 01 	lds	r20, 0x0109	; 0x800109 <IR_stageRX>
 30e:	41 30       	cpi	r20, 0x01	; 1
 310:	a9 f1       	breq	.+106    	; 0x37c <__vector_10+0x12e>
 312:	38 f0       	brcs	.+14     	; 0x322 <__vector_10+0xd4>
 314:	47 30       	cpi	r20, 0x07	; 7
 316:	09 f4       	brne	.+2      	; 0x31a <__vector_10+0xcc>
 318:	4e c0       	rjmp	.+156    	; 0x3b6 <__vector_10+0x168>
 31a:	48 30       	cpi	r20, 0x08	; 8
 31c:	09 f4       	brne	.+2      	; 0x320 <__vector_10+0xd2>
 31e:	d4 c0       	rjmp	.+424    	; 0x4c8 <__EEPROM_REGION_LENGTH__+0xc8>
 320:	d6 c0       	rjmp	.+428    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
		case IR_STAGE_PULSE_1:
			IR_frameStart = false;
			IR_protocolType = 0;
 322:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <IR_protocolType>
			IR_stageRX = IR_STAGE_PULSE_2;
 326:	41 e0       	ldi	r20, 0x01	; 1
 328:	40 93 09 01 	sts	0x0109, r20	; 0x800109 <IR_stageRX>
		
			if(pulse_length < IR_NEC_AGC_MAX_TIME && pulse_length > IR_NEC_AGC_MIN_TIME){
 32c:	ab 01       	movw	r20, r22
 32e:	49 52       	subi	r20, 0x29	; 41
 330:	53 42       	sbci	r21, 0x23	; 35
 332:	4b 32       	cpi	r20, 0x2B	; 43
 334:	51 40       	sbci	r21, 0x01	; 1
 336:	20 f4       	brcc	.+8      	; 0x340 <__vector_10+0xf2>
				// NEC protocol, AGC pulse
				IR_protocolType = IR_PROTOCOL_NEC;
 338:	81 e0       	ldi	r24, 0x01	; 1
 33a:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <IR_protocolType>
 33e:	c7 c0       	rjmp	.+398    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
			}else if(pulse_level == 0 && pulse_length > IR_RC5_MIN_TIME && pulse_length < IR_RC5_MAX_TIME){
 340:	c1 11       	cpse	r28, r1
 342:	c5 c0       	rjmp	.+394    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
 344:	61 37       	cpi	r22, 0x71	; 113
 346:	73 40       	sbci	r23, 0x03	; 3
 348:	08 f4       	brcc	.+2      	; 0x34c <__vector_10+0xfe>
 34a:	c1 c0       	rjmp	.+386    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
 34c:	24 3d       	cpi	r18, 0xD4	; 212
 34e:	83 e0       	ldi	r24, 0x03	; 3
 350:	38 07       	cpc	r19, r24
 352:	08 f0       	brcs	.+2      	; 0x356 <__vector_10+0x108>
 354:	bc c0       	rjmp	.+376    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
				// RC-5 protocol
				// Second half of the Start Bit 1
				IR_protocolType = IR_PROTOCOL_RC5;
 356:	83 e0       	ldi	r24, 0x03	; 3
 358:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <IR_protocolType>
				IR_stageRX = IR_STAGE_DATA_BITS;
 35c:	87 e0       	ldi	r24, 0x07	; 7
 35e:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <IR_stageRX>
				IR_RXexpectedBits = 13;
 362:	8d e0       	ldi	r24, 0x0D	; 13
 364:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <IR_RXexpectedBits>
			
				if(pulse_length > IR_RC5_JOINED_BITS_TIME){
 368:	2d 3d       	cpi	r18, 0xDD	; 221
 36a:	35 40       	sbci	r19, 0x05	; 5
 36c:	08 f4       	brcc	.+2      	; 0x370 <__vector_10+0x122>
 36e:	af c0       	rjmp	.+350    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
					IR_waitNextPulse++;
 370:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <IR_waitNextPulse>
 374:	8f 5f       	subi	r24, 0xFF	; 255
 376:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <IR_waitNextPulse>
 37a:	a9 c0       	rjmp	.+338    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
				}
			}
		break;
			
		case IR_STAGE_PULSE_2:	
			if(IR_protocolType == IR_PROTOCOL_NEC){
 37c:	20 91 0c 01 	lds	r18, 0x010C	; 0x80010c <IR_protocolType>
 380:	21 30       	cpi	r18, 0x01	; 1
 382:	09 f0       	breq	.+2      	; 0x386 <__vector_10+0x138>
 384:	a4 c0       	rjmp	.+328    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
				if(pulse_length < IR_NEC_LONG_PAUSE_MAX_TIME && pulse_length > IR_NEC_LONG_PAUSE_MIN_TIME){
 386:	9b 01       	movw	r18, r22
 388:	2d 5c       	subi	r18, 0xCD	; 205
 38a:	30 41       	sbci	r19, 0x10	; 16
 38c:	2b 32       	cpi	r18, 0x2B	; 43
 38e:	31 40       	sbci	r19, 0x01	; 1
 390:	20 f4       	brcc	.+8      	; 0x39a <__vector_10+0x14c>
					// Check for long pause
					IR_stageRX = IR_STAGE_DATA_BITS;
 392:	87 e0       	ldi	r24, 0x07	; 7
 394:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <IR_stageRX>
 398:	9a c0       	rjmp	.+308    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>

				}else if(pulse_length < IR_NEC_SHORT_PAUSE_MAX_TIME && pulse_length > IR_NEC_SHORT_PAUSE_MIN_TIME){
 39a:	ab 01       	movw	r20, r22
 39c:	41 5d       	subi	r20, 0xD1	; 209
 39e:	57 40       	sbci	r21, 0x07	; 7
 3a0:	4b 32       	cpi	r20, 0x2B	; 43
 3a2:	51 40       	sbci	r21, 0x01	; 1
 3a4:	08 f0       	brcs	.+2      	; 0x3a8 <__vector_10+0x15a>
 3a6:	93 c0       	rjmp	.+294    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
					// Check for short pause
					IR_RepeatCode = true;
 3a8:	81 e0       	ldi	r24, 0x01	; 1
 3aa:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <IR_RepeatCode>
					IR_stageRX = IR_STAGE_END;
 3ae:	89 e0       	ldi	r24, 0x09	; 9
 3b0:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <IR_stageRX>
 3b4:	8c c0       	rjmp	.+280    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
			}
		break;
	
		case IR_STAGE_DATA_BITS:
			// Collect NEC data bits - LSB is sent first
			if(IR_protocolType == IR_PROTOCOL_NEC){
 3b6:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <IR_protocolType>
 3ba:	81 30       	cpi	r24, 0x01	; 1
 3bc:	a1 f5       	brne	.+104    	; 0x426 <__EEPROM_REGION_LENGTH__+0x26>
				// Wait for two pulses to form a bit
				if(pulse_level){
 3be:	cc 23       	and	r28, r28
 3c0:	09 f4       	brne	.+2      	; 0x3c4 <__vector_10+0x176>
 3c2:	85 c0       	rjmp	.+266    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
					if(pulse_level && pulse_length > 1500){
 3c4:	21 f1       	breq	.+72     	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
 3c6:	2d 3d       	cpi	r18, 0xDD	; 221
 3c8:	35 40       	sbci	r19, 0x05	; 5
 3ca:	08 f1       	brcs	.+66     	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
						IR_dataRX |= ((uint32_t)1 << IR_RXexpectedBits);
 3cc:	81 e0       	ldi	r24, 0x01	; 1
 3ce:	90 e0       	ldi	r25, 0x00	; 0
 3d0:	a0 e0       	ldi	r26, 0x00	; 0
 3d2:	b0 e0       	ldi	r27, 0x00	; 0
 3d4:	00 90 0a 01 	lds	r0, 0x010A	; 0x80010a <IR_RXexpectedBits>
 3d8:	04 c0       	rjmp	.+8      	; 0x3e2 <__vector_10+0x194>
 3da:	88 0f       	add	r24, r24
 3dc:	99 1f       	adc	r25, r25
 3de:	aa 1f       	adc	r26, r26
 3e0:	bb 1f       	adc	r27, r27
 3e2:	0a 94       	dec	r0
 3e4:	d2 f7       	brpl	.-12     	; 0x3da <__vector_10+0x18c>
 3e6:	40 91 11 01 	lds	r20, 0x0111	; 0x800111 <IR_dataRX>
 3ea:	50 91 12 01 	lds	r21, 0x0112	; 0x800112 <IR_dataRX+0x1>
 3ee:	60 91 13 01 	lds	r22, 0x0113	; 0x800113 <IR_dataRX+0x2>
 3f2:	70 91 14 01 	lds	r23, 0x0114	; 0x800114 <IR_dataRX+0x3>
 3f6:	84 2b       	or	r24, r20
 3f8:	95 2b       	or	r25, r21
 3fa:	a6 2b       	or	r26, r22
 3fc:	b7 2b       	or	r27, r23
 3fe:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <IR_dataRX>
 402:	90 93 12 01 	sts	0x0112, r25	; 0x800112 <IR_dataRX+0x1>
 406:	a0 93 13 01 	sts	0x0113, r26	; 0x800113 <IR_dataRX+0x2>
 40a:	b0 93 14 01 	sts	0x0114, r27	; 0x800114 <IR_dataRX+0x3>
					}

					IR_RXexpectedBits++;
 40e:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <IR_RXexpectedBits>
 412:	8f 5f       	subi	r24, 0xFF	; 255
 414:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <IR_RXexpectedBits>

					// All bits received. Wait for STOP bit.
					if(IR_RXexpectedBits > 31){
 418:	80 32       	cpi	r24, 0x20	; 32
 41a:	08 f4       	brcc	.+2      	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
 41c:	58 c0       	rjmp	.+176    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
						IR_stageRX = IR_STAGE_STOP_BIT;
 41e:	88 e0       	ldi	r24, 0x08	; 8
 420:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <IR_stageRX>
 424:	54 c0       	rjmp	.+168    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
					}
				}
			
			// Collect RC-5 data bits - MSB is sent first
			}else if(IR_protocolType == IR_PROTOCOL_RC5){
 426:	83 30       	cpi	r24, 0x03	; 3
 428:	09 f0       	breq	.+2      	; 0x42c <__EEPROM_REGION_LENGTH__+0x2c>
 42a:	51 c0       	rjmp	.+162    	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
				IR_waitNextPulse++;
 42c:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <IR_waitNextPulse>
 430:	8f 5f       	subi	r24, 0xFF	; 255
 432:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <IR_waitNextPulse>
			
				// Wait for two pulses to form a bit
				if(IR_waitNextPulse > 1){
 436:	82 30       	cpi	r24, 0x02	; 2
 438:	60 f1       	brcs	.+88     	; 0x492 <__EEPROM_REGION_LENGTH__+0x92>
					IR_waitNextPulse = 0;
 43a:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <IR_waitNextPulse>
					IR_RXexpectedBits--;
 43e:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <IR_RXexpectedBits>
 442:	81 50       	subi	r24, 0x01	; 1
 444:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <IR_RXexpectedBits>
				
					if(pulse_level == 0){
 448:	c1 11       	cpse	r28, r1
 44a:	23 c0       	rjmp	.+70     	; 0x492 <__EEPROM_REGION_LENGTH__+0x92>
						IR_dataRX |= ((uint32_t)1 << IR_RXexpectedBits);
 44c:	41 e0       	ldi	r20, 0x01	; 1
 44e:	50 e0       	ldi	r21, 0x00	; 0
 450:	60 e0       	ldi	r22, 0x00	; 0
 452:	70 e0       	ldi	r23, 0x00	; 0
 454:	7a 01       	movw	r14, r20
 456:	8b 01       	movw	r16, r22
 458:	04 c0       	rjmp	.+8      	; 0x462 <__EEPROM_REGION_LENGTH__+0x62>
 45a:	ee 0c       	add	r14, r14
 45c:	ff 1c       	adc	r15, r15
 45e:	00 1f       	adc	r16, r16
 460:	11 1f       	adc	r17, r17
 462:	8a 95       	dec	r24
 464:	d2 f7       	brpl	.-12     	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>
 466:	d8 01       	movw	r26, r16
 468:	c7 01       	movw	r24, r14
 46a:	40 91 11 01 	lds	r20, 0x0111	; 0x800111 <IR_dataRX>
 46e:	50 91 12 01 	lds	r21, 0x0112	; 0x800112 <IR_dataRX+0x1>
 472:	60 91 13 01 	lds	r22, 0x0113	; 0x800113 <IR_dataRX+0x2>
 476:	70 91 14 01 	lds	r23, 0x0114	; 0x800114 <IR_dataRX+0x3>
 47a:	84 2b       	or	r24, r20
 47c:	95 2b       	or	r25, r21
 47e:	a6 2b       	or	r26, r22
 480:	b7 2b       	or	r27, r23
 482:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <IR_dataRX>
 486:	90 93 12 01 	sts	0x0112, r25	; 0x800112 <IR_dataRX+0x1>
 48a:	a0 93 13 01 	sts	0x0113, r26	; 0x800113 <IR_dataRX+0x2>
 48e:	b0 93 14 01 	sts	0x0114, r27	; 0x800114 <IR_dataRX+0x3>
					}
				}
			
				// Received half of the next bit
				if(pulse_length > IR_RC5_JOINED_BITS_TIME){
 492:	2d 3d       	cpi	r18, 0xDD	; 221
 494:	35 40       	sbci	r19, 0x05	; 5
 496:	28 f0       	brcs	.+10     	; 0x4a2 <__EEPROM_REGION_LENGTH__+0xa2>
					IR_waitNextPulse++;
 498:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <IR_waitNextPulse>
 49c:	8f 5f       	subi	r24, 0xFF	; 255
 49e:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <IR_waitNextPulse>
				}
			
				// All bits received
				if(IR_RXexpectedBits == 1 && IR_waitNextPulse == 1 && pulse_level == 0){
 4a2:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <IR_RXexpectedBits>
 4a6:	81 30       	cpi	r24, 0x01	; 1
 4a8:	49 f4       	brne	.+18     	; 0x4bc <__EEPROM_REGION_LENGTH__+0xbc>
 4aa:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <IR_waitNextPulse>
 4ae:	91 30       	cpi	r25, 0x01	; 1
 4b0:	29 f4       	brne	.+10     	; 0x4bc <__EEPROM_REGION_LENGTH__+0xbc>
 4b2:	c1 11       	cpse	r28, r1
 4b4:	03 c0       	rjmp	.+6      	; 0x4bc <__EEPROM_REGION_LENGTH__+0xbc>
					// The case when bit 0 is at the end
					IR_stageRX = IR_STAGE_END;
 4b6:	99 e0       	ldi	r25, 0x09	; 9
 4b8:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <IR_stageRX>
				}

				if(IR_RXexpectedBits == 0){
 4bc:	81 11       	cpse	r24, r1
 4be:	07 c0       	rjmp	.+14     	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
					// The case when bit 1 is at the end
					IR_stageRX = IR_STAGE_END;
 4c0:	89 e0       	ldi	r24, 0x09	; 9
 4c2:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <IR_stageRX>
 4c6:	03 c0       	rjmp	.+6      	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
				}
			}
		break;
		
		case IR_STAGE_STOP_BIT:
			IR_stageRX = IR_STAGE_END;
 4c8:	89 e0       	ldi	r24, 0x09	; 9
 4ca:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <IR_stageRX>
	}
}
 4ce:	ff 91       	pop	r31
 4d0:	ef 91       	pop	r30
 4d2:	cf 91       	pop	r28
 4d4:	bf 91       	pop	r27
 4d6:	af 91       	pop	r26
 4d8:	9f 91       	pop	r25
 4da:	8f 91       	pop	r24
 4dc:	7f 91       	pop	r23
 4de:	6f 91       	pop	r22
 4e0:	5f 91       	pop	r21
 4e2:	4f 91       	pop	r20
 4e4:	3f 91       	pop	r19
 4e6:	2f 91       	pop	r18
 4e8:	1f 91       	pop	r17
 4ea:	0f 91       	pop	r16
 4ec:	ff 90       	pop	r15
 4ee:	ef 90       	pop	r14
 4f0:	0f 90       	pop	r0
 4f2:	0f be       	out	0x3f, r0	; 63
 4f4:	0f 90       	pop	r0
 4f6:	1f 90       	pop	r1
 4f8:	18 95       	reti

000004fa <__vector_13>:


// Timer/Counter Overflow
ISR(TIMERn_OVF_vect){
 4fa:	1f 92       	push	r1
 4fc:	0f 92       	push	r0
 4fe:	0f b6       	in	r0, 0x3f	; 63
 500:	0f 92       	push	r0
 502:	11 24       	eor	r1, r1
 504:	8f 93       	push	r24
	IR_TimerOverflows++;
 506:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <IR_TimerOverflows>
 50a:	8f 5f       	subi	r24, 0xFF	; 255
 50c:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <IR_TimerOverflows>
}
 510:	8f 91       	pop	r24
 512:	0f 90       	pop	r0
 514:	0f be       	out	0x3f, r0	; 63
 516:	0f 90       	pop	r0
 518:	1f 90       	pop	r1
 51a:	18 95       	reti

0000051c <initPWM>:
uint8_t brightness = 255;
uint8_t mode = 0;

void initPWM(){
	// Reset Timer registers to 0
	TCCR0A = 0;
 51c:	14 bc       	out	0x24, r1	; 36
	TCCR0B = 0;
 51e:	15 bc       	out	0x25, r1	; 37
	TCCR2A = 0;
 520:	a0 eb       	ldi	r26, 0xB0	; 176
 522:	b0 e0       	ldi	r27, 0x00	; 0
 524:	1c 92       	st	X, r1
	TCCR2B = 0;
 526:	e1 eb       	ldi	r30, 0xB1	; 177
 528:	f0 e0       	ldi	r31, 0x00	; 0
 52a:	10 82       	st	Z, r1
	
	// Set Pins to Output
	DDRD |= _BV(DDD5);
 52c:	8a b1       	in	r24, 0x0a	; 10
 52e:	80 62       	ori	r24, 0x20	; 32
 530:	8a b9       	out	0x0a, r24	; 10
	DDRD |= _BV(DDD6);
 532:	8a b1       	in	r24, 0x0a	; 10
 534:	80 64       	ori	r24, 0x40	; 64
 536:	8a b9       	out	0x0a, r24	; 10
	DDRD |= _BV(DDD3);
 538:	8a b1       	in	r24, 0x0a	; 10
 53a:	88 60       	ori	r24, 0x08	; 8
 53c:	8a b9       	out	0x0a, r24	; 10
	DDRB |= _BV(DDB3);
 53e:	84 b1       	in	r24, 0x04	; 4
 540:	88 60       	ori	r24, 0x08	; 8
 542:	84 b9       	out	0x04, r24	; 4
	
	// TCCR0A [ COM0A1 0 COM0B1 0 0 0 WGM01 WGM00 ] = 0b10100011
	TCCR0A = _BV(COM0A1) | _BV(COM0B1) | _BV(WGM01) | _BV(WGM00);
 544:	93 ea       	ldi	r25, 0xA3	; 163
 546:	94 bd       	out	0x24, r25	; 36

	// Previous code will start from dim light LEDs
	//TCCR0A = _BV(WGM01) | _BV(WGM00);
	
	// TCCR0B [ FOC2A FOC2B 0 0 WGM02 CS02 CS01 CS00 ] = 0b00000011
	TCCR0B = _BV(CS01) | _BV(CS00); // Fast PWM set upper to 0xFF
 548:	83 e0       	ldi	r24, 0x03	; 3
 54a:	85 bd       	out	0x25, r24	; 37
	
	// For Pin set 3 and 11
	TCCR2A = _BV(COM2A1) | _BV(COM2B1) | _BV(WGM21) | _BV(WGM20);
 54c:	9c 93       	st	X, r25
	//TCCR2A =  _BV(WGM21) | _BV(WGM20);
	TCCR2B = _BV(CS21) | _BV(CS20);
 54e:	80 83       	st	Z, r24
 550:	08 95       	ret

00000552 <initRGB>:
	
}

void initRGB(){
	DDRD |= _BV(DDD2);
 552:	8a b1       	in	r24, 0x0a	; 10
 554:	84 60       	ori	r24, 0x04	; 4
 556:	8a b9       	out	0x0a, r24	; 10
	DDRD |= _BV(DDD4);
 558:	8a b1       	in	r24, 0x0a	; 10
 55a:	80 61       	ori	r24, 0x10	; 16
 55c:	8a b9       	out	0x0a, r24	; 10
	DDRD |= _BV(DDD7);
 55e:	8a b1       	in	r24, 0x0a	; 10
 560:	80 68       	ori	r24, 0x80	; 128
 562:	8a b9       	out	0x0a, r24	; 10
 564:	08 95       	ret

00000566 <set_Pin>:


// Controls the LEDs
// To set brightness can go with another function but lets go with this
void set_Pin(){
	switch(mode){
 566:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <__data_end>
 56a:	8e 2f       	mov	r24, r30
 56c:	90 e0       	ldi	r25, 0x00	; 0
 56e:	88 30       	cpi	r24, 0x08	; 8
 570:	91 05       	cpc	r25, r1
 572:	08 f0       	brcs	.+2      	; 0x576 <set_Pin+0x10>
 574:	b1 c0       	rjmp	.+354    	; 0x6d8 <set_Pin+0x172>
 576:	fc 01       	movw	r30, r24
 578:	ec 5c       	subi	r30, 0xCC	; 204
 57a:	ff 4f       	sbci	r31, 0xFF	; 255
 57c:	0c 94 0a 05 	jmp	0xa14	; 0xa14 <__tablejump2__>
		case 0:
			TCCR2A &= ~(_BV(COM2A1));
 580:	e0 eb       	ldi	r30, 0xB0	; 176
 582:	f0 e0       	ldi	r31, 0x00	; 0
 584:	80 81       	ld	r24, Z
 586:	8f 77       	andi	r24, 0x7F	; 127
 588:	80 83       	st	Z, r24
			break;
 58a:	08 95       	ret
		
		case 1:
			TCCR2A |= _BV(COM2A1);
 58c:	e0 eb       	ldi	r30, 0xB0	; 176
 58e:	f0 e0       	ldi	r31, 0x00	; 0
 590:	80 81       	ld	r24, Z
 592:	80 68       	ori	r24, 0x80	; 128
 594:	80 83       	st	Z, r24
			OCR2A = brightness;
 596:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 59a:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
			TCCR0A &= ~(_BV(COM0A1));
 59e:	84 b5       	in	r24, 0x24	; 36
 5a0:	8f 77       	andi	r24, 0x7F	; 127
 5a2:	84 bd       	out	0x24, r24	; 36
			
			break;
 5a4:	08 95       	ret
		case 2:
			TCCR2A |= _BV(COM2A1);
 5a6:	e0 eb       	ldi	r30, 0xB0	; 176
 5a8:	f0 e0       	ldi	r31, 0x00	; 0
 5aa:	80 81       	ld	r24, Z
 5ac:	80 68       	ori	r24, 0x80	; 128
 5ae:	80 83       	st	Z, r24
			TCCR0A |= _BV(COM0A1);
 5b0:	84 b5       	in	r24, 0x24	; 36
 5b2:	80 68       	ori	r24, 0x80	; 128
 5b4:	84 bd       	out	0x24, r24	; 36
			OCR2A = brightness;
 5b6:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 5ba:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
			OCR0A = brightness;
 5be:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 5c2:	87 bd       	out	0x27, r24	; 39
			TCCR0A &= ~(_BV(COM0B1));
 5c4:	84 b5       	in	r24, 0x24	; 36
 5c6:	8f 7d       	andi	r24, 0xDF	; 223
 5c8:	84 bd       	out	0x24, r24	; 36
			break;
 5ca:	08 95       	ret
			
		case 3:
			TCCR2A |= _BV(COM2A1);
 5cc:	e0 eb       	ldi	r30, 0xB0	; 176
 5ce:	f0 e0       	ldi	r31, 0x00	; 0
 5d0:	80 81       	ld	r24, Z
 5d2:	80 68       	ori	r24, 0x80	; 128
 5d4:	80 83       	st	Z, r24
			TCCR0A |= _BV(COM0A1);
 5d6:	84 b5       	in	r24, 0x24	; 36
 5d8:	80 68       	ori	r24, 0x80	; 128
 5da:	84 bd       	out	0x24, r24	; 36
			TCCR0A |= _BV(COM0B1);
 5dc:	84 b5       	in	r24, 0x24	; 36
 5de:	80 62       	ori	r24, 0x20	; 32
 5e0:	84 bd       	out	0x24, r24	; 36
			OCR2A = brightness;
 5e2:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 5e6:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
			OCR0A = brightness;
 5ea:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 5ee:	87 bd       	out	0x27, r24	; 39
			OCR0B = brightness;
 5f0:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 5f4:	88 bd       	out	0x28, r24	; 40
			TCCR2A &= ~(_BV(COM2B1));
 5f6:	80 81       	ld	r24, Z
 5f8:	8f 7d       	andi	r24, 0xDF	; 223
 5fa:	80 83       	st	Z, r24
			break;
 5fc:	08 95       	ret
			
		case 4:
			TCCR2A |= _BV(COM2A1);
 5fe:	e0 eb       	ldi	r30, 0xB0	; 176
 600:	f0 e0       	ldi	r31, 0x00	; 0
 602:	80 81       	ld	r24, Z
 604:	80 68       	ori	r24, 0x80	; 128
 606:	80 83       	st	Z, r24
			TCCR0A |= _BV(COM0A1);
 608:	84 b5       	in	r24, 0x24	; 36
 60a:	80 68       	ori	r24, 0x80	; 128
 60c:	84 bd       	out	0x24, r24	; 36
			TCCR0A |= _BV(COM0B1);
 60e:	84 b5       	in	r24, 0x24	; 36
 610:	80 62       	ori	r24, 0x20	; 32
 612:	84 bd       	out	0x24, r24	; 36
			TCCR2A |= _BV(COM2B1);
 614:	80 81       	ld	r24, Z
 616:	80 62       	ori	r24, 0x20	; 32
 618:	80 83       	st	Z, r24
			OCR2A = brightness;
 61a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 61e:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
			OCR0A = brightness;
 622:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 626:	87 bd       	out	0x27, r24	; 39
			OCR0B = brightness;
 628:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 62c:	88 bd       	out	0x28, r24	; 40
			OCR2B = brightness;
 62e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 632:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7f80b4>
			
			PORTD &= ~(1 << PD2);
 636:	8b b1       	in	r24, 0x0b	; 11
 638:	8b 7f       	andi	r24, 0xFB	; 251
 63a:	8b b9       	out	0x0b, r24	; 11
			PORTD &= ~(1 << PD4);
 63c:	8b b1       	in	r24, 0x0b	; 11
 63e:	8f 7e       	andi	r24, 0xEF	; 239
 640:	8b b9       	out	0x0b, r24	; 11
			PORTD &= ~(1 << PD7);
 642:	8b b1       	in	r24, 0x0b	; 11
 644:	8f 77       	andi	r24, 0x7F	; 127
 646:	8b b9       	out	0x0b, r24	; 11
			break;
 648:	08 95       	ret
		case 5:
			OCR2A = brightness;
 64a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 64e:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
			OCR0A = brightness;
 652:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 656:	87 bd       	out	0x27, r24	; 39
			OCR0B = brightness;
 658:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 65c:	88 bd       	out	0x28, r24	; 40
			OCR2B = brightness;
 65e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 662:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7f80b4>
		
			PORTD|= (1 << PD2);
 666:	8b b1       	in	r24, 0x0b	; 11
 668:	84 60       	ori	r24, 0x04	; 4
 66a:	8b b9       	out	0x0b, r24	; 11
			PORTD |= (1 << PD4);
 66c:	8b b1       	in	r24, 0x0b	; 11
 66e:	80 61       	ori	r24, 0x10	; 16
 670:	8b b9       	out	0x0b, r24	; 11
			PORTD &= ~(1 << PD7);
 672:	8b b1       	in	r24, 0x0b	; 11
 674:	8f 77       	andi	r24, 0x7F	; 127
 676:	8b b9       	out	0x0b, r24	; 11
			break;
 678:	08 95       	ret
		case 6:
			OCR2A = brightness;
 67a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 67e:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
			OCR0A = brightness;
 682:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 686:	87 bd       	out	0x27, r24	; 39
			OCR0B = brightness;
 688:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 68c:	88 bd       	out	0x28, r24	; 40
			OCR2B = brightness;
 68e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 692:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7f80b4>
			
			PORTD |= (1 << PD2);
 696:	8b b1       	in	r24, 0x0b	; 11
 698:	84 60       	ori	r24, 0x04	; 4
 69a:	8b b9       	out	0x0b, r24	; 11
			PORTD &= ~(1 << PD4);
 69c:	8b b1       	in	r24, 0x0b	; 11
 69e:	8f 7e       	andi	r24, 0xEF	; 239
 6a0:	8b b9       	out	0x0b, r24	; 11
			PORTD |= (1 << PD7);
 6a2:	8b b1       	in	r24, 0x0b	; 11
 6a4:	80 68       	ori	r24, 0x80	; 128
 6a6:	8b b9       	out	0x0b, r24	; 11
			break;
 6a8:	08 95       	ret
		case 7:
			OCR2A = brightness;
 6aa:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 6ae:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f80b3>
			OCR0A = brightness;
 6b2:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 6b6:	87 bd       	out	0x27, r24	; 39
			OCR0B = brightness;
 6b8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 6bc:	88 bd       	out	0x28, r24	; 40
			OCR2B = brightness;
 6be:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 6c2:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7f80b4>
			
			PORTD &= ~(1 << PD2);
 6c6:	8b b1       	in	r24, 0x0b	; 11
 6c8:	8b 7f       	andi	r24, 0xFB	; 251
 6ca:	8b b9       	out	0x0b, r24	; 11
			PORTD |= (1 << PD4);
 6cc:	8b b1       	in	r24, 0x0b	; 11
 6ce:	80 61       	ori	r24, 0x10	; 16
 6d0:	8b b9       	out	0x0b, r24	; 11
			PORTD |= (1 << PD7);
 6d2:	8b b1       	in	r24, 0x0b	; 11
 6d4:	80 68       	ori	r24, 0x80	; 128
 6d6:	8b b9       	out	0x0b, r24	; 11
 6d8:	08 95       	ret

000006da <vol_Up>:
// Using multiples of 255 to avoid bit flips beyond or below 255, 0 respectively
// 17-> 15 bright levels ,51 -> 5 Bright levels,85 -> 3 levels

void vol_Up(){
	
	if (brightness < 255){
 6da:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 6de:	8f 3f       	cpi	r24, 0xFF	; 255
 6e0:	19 f0       	breq	.+6      	; 0x6e8 <vol_Up+0xe>
		brightness += 51;
 6e2:	8d 5c       	subi	r24, 0xCD	; 205
 6e4:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
	}
	set_Pin();
 6e8:	0e 94 b3 02 	call	0x566	; 0x566 <set_Pin>
 6ec:	08 95       	ret

000006ee <vol_Down>:
}

void vol_Down(){
	
	if (brightness > 0){
 6ee:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 6f2:	88 23       	and	r24, r24
 6f4:	19 f0       	breq	.+6      	; 0x6fc <vol_Down+0xe>
		brightness -= 51;
 6f6:	83 53       	subi	r24, 0x33	; 51
 6f8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
	}
	set_Pin();
 6fc:	0e 94 b3 02 	call	0x566	; 0x566 <set_Pin>
 700:	08 95       	ret

00000702 <key_Up>:
}

void key_Up(){
	if (mode < 7){
 702:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_end>
 706:	87 30       	cpi	r24, 0x07	; 7
 708:	28 f4       	brcc	.+10     	; 0x714 <key_Up+0x12>
		mode++;
 70a:	8f 5f       	subi	r24, 0xFF	; 255
 70c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_end>
		set_Pin();
 710:	0e 94 b3 02 	call	0x566	; 0x566 <set_Pin>
 714:	08 95       	ret

00000716 <key_Down>:
	}
}

void key_Down(){
	if (mode > 0){
 716:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__data_end>
 71a:	88 23       	and	r24, r24
 71c:	29 f0       	breq	.+10     	; 0x728 <key_Down+0x12>
		mode--;
 71e:	81 50       	subi	r24, 0x01	; 1
 720:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_end>
		set_Pin();
 724:	0e 94 b3 02 	call	0x566	; 0x566 <set_Pin>
 728:	08 95       	ret

0000072a <check_command>:
	}
}

void check_command(uint16_t code){
	switch(code){
 72a:	81 30       	cpi	r24, 0x01	; 1
 72c:	91 05       	cpc	r25, r1
 72e:	81 f0       	breq	.+32     	; 0x750 <check_command+0x26>
 730:	60 f0       	brcs	.+24     	; 0x74a <check_command+0x20>
 732:	82 30       	cpi	r24, 0x02	; 2
 734:	91 05       	cpc	r25, r1
 736:	19 f0       	breq	.+6      	; 0x73e <check_command+0x14>
 738:	03 97       	sbiw	r24, 0x03	; 3
 73a:	21 f0       	breq	.+8      	; 0x744 <check_command+0x1a>
 73c:	08 95       	ret
		case vol_up:
			vol_Up();
 73e:	0e 94 6d 03 	call	0x6da	; 0x6da <vol_Up>
			break;
 742:	08 95       	ret
		case vol_down:
			vol_Down();
 744:	0e 94 77 03 	call	0x6ee	; 0x6ee <vol_Down>
			break;
 748:	08 95       	ret
		case key_up:
			key_Up();
 74a:	0e 94 81 03 	call	0x702	; 0x702 <key_Up>
			break;
 74e:	08 95       	ret
		case key_down:
			key_Down();
 750:	0e 94 8b 03 	call	0x716	; 0x716 <key_Down>
 754:	08 95       	ret

00000756 <set_initial>:
			break;
	}
}

void set_initial(){
	TCCR2A &= ~(_BV(COM2A1));
 756:	e0 eb       	ldi	r30, 0xB0	; 176
 758:	f0 e0       	ldi	r31, 0x00	; 0
 75a:	80 81       	ld	r24, Z
 75c:	8f 77       	andi	r24, 0x7F	; 127
 75e:	80 83       	st	Z, r24
	TCCR0A &= ~(_BV(COM0B1));
 760:	84 b5       	in	r24, 0x24	; 36
 762:	8f 7d       	andi	r24, 0xDF	; 223
 764:	84 bd       	out	0x24, r24	; 36
	TCCR0A &= ~(_BV(COM0A1));
 766:	84 b5       	in	r24, 0x24	; 36
 768:	8f 77       	andi	r24, 0x7F	; 127
 76a:	84 bd       	out	0x24, r24	; 36
	TCCR2A &= ~(_BV(COM2B1));
 76c:	80 81       	ld	r24, Z
 76e:	8f 7d       	andi	r24, 0xDF	; 223
 770:	80 83       	st	Z, r24
 772:	08 95       	ret

00000774 <main>:
}

int main(void)
{	
 774:	cf 93       	push	r28
 776:	df 93       	push	r29
 778:	00 d0       	rcall	.+0      	; 0x77a <main+0x6>
 77a:	00 d0       	rcall	.+0      	; 0x77c <main+0x8>
 77c:	cd b7       	in	r28, 0x3d	; 61
 77e:	de b7       	in	r29, 0x3e	; 62
	uint16_t address = 0; // Variable to store IR address
 780:	1a 82       	std	Y+2, r1	; 0x02
 782:	19 82       	std	Y+1, r1	; 0x01
	uint16_t command = 0; // Variable to store IR command
 784:	1c 82       	std	Y+4, r1	; 0x04
 786:	1b 82       	std	Y+3, r1	; 0x03
    
	initPWM();
 788:	0e 94 8e 02 	call	0x51c	; 0x51c <initPWM>
	initRGB();
 78c:	0e 94 a9 02 	call	0x552	; 0x552 <initRGB>
	IR_init();
 790:	0e 94 6a 00 	call	0xd4	; 0xd4 <IR_init>
	
	set_initial(); // Sets to initial State
 794:	0e 94 ab 03 	call	0x756	; 0x756 <set_initial>
	
    while (1) 
    {	
		//DDRD |= (1 << DDD4);
		
		if (IR_codeAvailable()) { // Check if IR code is available
 798:	0e 94 7f 00 	call	0xfe	; 0xfe <IR_codeAvailable>
 79c:	88 23       	and	r24, r24
 79e:	e1 f3       	breq	.-8      	; 0x798 <main+0x24>
			//Debug
			//PORTD |= (1<<PD4);
			//_delay_ms(2000);
			if (!IR_isRepeatCode()) { // Check if IR code is not a repeat
 7a0:	0e 94 22 01 	call	0x244	; 0x244 <IR_isRepeatCode>
 7a4:	81 11       	cpse	r24, r1
 7a6:	f8 cf       	rjmp	.-16     	; 0x798 <main+0x24>
				IR_getCode(&address, &command); // Get IR address and command
 7a8:	be 01       	movw	r22, r28
 7aa:	6d 5f       	subi	r22, 0xFD	; 253
 7ac:	7f 4f       	sbci	r23, 0xFF	; 255
 7ae:	ce 01       	movw	r24, r28
 7b0:	01 96       	adiw	r24, 0x01	; 1
 7b2:	0e 94 0b 01 	call	0x216	; 0x216 <IR_getCode>
				check_command(command);
 7b6:	8b 81       	ldd	r24, Y+3	; 0x03
 7b8:	9c 81       	ldd	r25, Y+4	; 0x04
 7ba:	0e 94 95 03 	call	0x72a	; 0x72a <check_command>
 7be:	ec cf       	rjmp	.-40     	; 0x798 <main+0x24>

000007c0 <__fixunssfsi>:
 7c0:	0e 94 54 04 	call	0x8a8	; 0x8a8 <__fp_splitA>
 7c4:	88 f0       	brcs	.+34     	; 0x7e8 <__fixunssfsi+0x28>
 7c6:	9f 57       	subi	r25, 0x7F	; 127
 7c8:	98 f0       	brcs	.+38     	; 0x7f0 <__fixunssfsi+0x30>
 7ca:	b9 2f       	mov	r27, r25
 7cc:	99 27       	eor	r25, r25
 7ce:	b7 51       	subi	r27, 0x17	; 23
 7d0:	b0 f0       	brcs	.+44     	; 0x7fe <__fixunssfsi+0x3e>
 7d2:	e1 f0       	breq	.+56     	; 0x80c <__DATA_REGION_LENGTH__+0xc>
 7d4:	66 0f       	add	r22, r22
 7d6:	77 1f       	adc	r23, r23
 7d8:	88 1f       	adc	r24, r24
 7da:	99 1f       	adc	r25, r25
 7dc:	1a f0       	brmi	.+6      	; 0x7e4 <__fixunssfsi+0x24>
 7de:	ba 95       	dec	r27
 7e0:	c9 f7       	brne	.-14     	; 0x7d4 <__fixunssfsi+0x14>
 7e2:	14 c0       	rjmp	.+40     	; 0x80c <__DATA_REGION_LENGTH__+0xc>
 7e4:	b1 30       	cpi	r27, 0x01	; 1
 7e6:	91 f0       	breq	.+36     	; 0x80c <__DATA_REGION_LENGTH__+0xc>
 7e8:	0e 94 6e 04 	call	0x8dc	; 0x8dc <__fp_zero>
 7ec:	b1 e0       	ldi	r27, 0x01	; 1
 7ee:	08 95       	ret
 7f0:	0c 94 6e 04 	jmp	0x8dc	; 0x8dc <__fp_zero>
 7f4:	67 2f       	mov	r22, r23
 7f6:	78 2f       	mov	r23, r24
 7f8:	88 27       	eor	r24, r24
 7fa:	b8 5f       	subi	r27, 0xF8	; 248
 7fc:	39 f0       	breq	.+14     	; 0x80c <__DATA_REGION_LENGTH__+0xc>
 7fe:	b9 3f       	cpi	r27, 0xF9	; 249
 800:	cc f3       	brlt	.-14     	; 0x7f4 <__fixunssfsi+0x34>
 802:	86 95       	lsr	r24
 804:	77 95       	ror	r23
 806:	67 95       	ror	r22
 808:	b3 95       	inc	r27
 80a:	d9 f7       	brne	.-10     	; 0x802 <__DATA_REGION_LENGTH__+0x2>
 80c:	3e f4       	brtc	.+14     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
 80e:	90 95       	com	r25
 810:	80 95       	com	r24
 812:	70 95       	com	r23
 814:	61 95       	neg	r22
 816:	7f 4f       	sbci	r23, 0xFF	; 255
 818:	8f 4f       	sbci	r24, 0xFF	; 255
 81a:	9f 4f       	sbci	r25, 0xFF	; 255
 81c:	08 95       	ret

0000081e <__floatunsisf>:
 81e:	e8 94       	clt
 820:	09 c0       	rjmp	.+18     	; 0x834 <__floatsisf+0x12>

00000822 <__floatsisf>:
 822:	97 fb       	bst	r25, 7
 824:	3e f4       	brtc	.+14     	; 0x834 <__floatsisf+0x12>
 826:	90 95       	com	r25
 828:	80 95       	com	r24
 82a:	70 95       	com	r23
 82c:	61 95       	neg	r22
 82e:	7f 4f       	sbci	r23, 0xFF	; 255
 830:	8f 4f       	sbci	r24, 0xFF	; 255
 832:	9f 4f       	sbci	r25, 0xFF	; 255
 834:	99 23       	and	r25, r25
 836:	a9 f0       	breq	.+42     	; 0x862 <__floatsisf+0x40>
 838:	f9 2f       	mov	r31, r25
 83a:	96 e9       	ldi	r25, 0x96	; 150
 83c:	bb 27       	eor	r27, r27
 83e:	93 95       	inc	r25
 840:	f6 95       	lsr	r31
 842:	87 95       	ror	r24
 844:	77 95       	ror	r23
 846:	67 95       	ror	r22
 848:	b7 95       	ror	r27
 84a:	f1 11       	cpse	r31, r1
 84c:	f8 cf       	rjmp	.-16     	; 0x83e <__floatsisf+0x1c>
 84e:	fa f4       	brpl	.+62     	; 0x88e <__floatsisf+0x6c>
 850:	bb 0f       	add	r27, r27
 852:	11 f4       	brne	.+4      	; 0x858 <__floatsisf+0x36>
 854:	60 ff       	sbrs	r22, 0
 856:	1b c0       	rjmp	.+54     	; 0x88e <__floatsisf+0x6c>
 858:	6f 5f       	subi	r22, 0xFF	; 255
 85a:	7f 4f       	sbci	r23, 0xFF	; 255
 85c:	8f 4f       	sbci	r24, 0xFF	; 255
 85e:	9f 4f       	sbci	r25, 0xFF	; 255
 860:	16 c0       	rjmp	.+44     	; 0x88e <__floatsisf+0x6c>
 862:	88 23       	and	r24, r24
 864:	11 f0       	breq	.+4      	; 0x86a <__floatsisf+0x48>
 866:	96 e9       	ldi	r25, 0x96	; 150
 868:	11 c0       	rjmp	.+34     	; 0x88c <__floatsisf+0x6a>
 86a:	77 23       	and	r23, r23
 86c:	21 f0       	breq	.+8      	; 0x876 <__floatsisf+0x54>
 86e:	9e e8       	ldi	r25, 0x8E	; 142
 870:	87 2f       	mov	r24, r23
 872:	76 2f       	mov	r23, r22
 874:	05 c0       	rjmp	.+10     	; 0x880 <__floatsisf+0x5e>
 876:	66 23       	and	r22, r22
 878:	71 f0       	breq	.+28     	; 0x896 <__floatsisf+0x74>
 87a:	96 e8       	ldi	r25, 0x86	; 134
 87c:	86 2f       	mov	r24, r22
 87e:	70 e0       	ldi	r23, 0x00	; 0
 880:	60 e0       	ldi	r22, 0x00	; 0
 882:	2a f0       	brmi	.+10     	; 0x88e <__floatsisf+0x6c>
 884:	9a 95       	dec	r25
 886:	66 0f       	add	r22, r22
 888:	77 1f       	adc	r23, r23
 88a:	88 1f       	adc	r24, r24
 88c:	da f7       	brpl	.-10     	; 0x884 <__floatsisf+0x62>
 88e:	88 0f       	add	r24, r24
 890:	96 95       	lsr	r25
 892:	87 95       	ror	r24
 894:	97 f9       	bld	r25, 7
 896:	08 95       	ret

00000898 <__fp_split3>:
 898:	57 fd       	sbrc	r21, 7
 89a:	90 58       	subi	r25, 0x80	; 128
 89c:	44 0f       	add	r20, r20
 89e:	55 1f       	adc	r21, r21
 8a0:	59 f0       	breq	.+22     	; 0x8b8 <__fp_splitA+0x10>
 8a2:	5f 3f       	cpi	r21, 0xFF	; 255
 8a4:	71 f0       	breq	.+28     	; 0x8c2 <__fp_splitA+0x1a>
 8a6:	47 95       	ror	r20

000008a8 <__fp_splitA>:
 8a8:	88 0f       	add	r24, r24
 8aa:	97 fb       	bst	r25, 7
 8ac:	99 1f       	adc	r25, r25
 8ae:	61 f0       	breq	.+24     	; 0x8c8 <__fp_splitA+0x20>
 8b0:	9f 3f       	cpi	r25, 0xFF	; 255
 8b2:	79 f0       	breq	.+30     	; 0x8d2 <__fp_splitA+0x2a>
 8b4:	87 95       	ror	r24
 8b6:	08 95       	ret
 8b8:	12 16       	cp	r1, r18
 8ba:	13 06       	cpc	r1, r19
 8bc:	14 06       	cpc	r1, r20
 8be:	55 1f       	adc	r21, r21
 8c0:	f2 cf       	rjmp	.-28     	; 0x8a6 <__fp_split3+0xe>
 8c2:	46 95       	lsr	r20
 8c4:	f1 df       	rcall	.-30     	; 0x8a8 <__fp_splitA>
 8c6:	08 c0       	rjmp	.+16     	; 0x8d8 <__fp_splitA+0x30>
 8c8:	16 16       	cp	r1, r22
 8ca:	17 06       	cpc	r1, r23
 8cc:	18 06       	cpc	r1, r24
 8ce:	99 1f       	adc	r25, r25
 8d0:	f1 cf       	rjmp	.-30     	; 0x8b4 <__fp_splitA+0xc>
 8d2:	86 95       	lsr	r24
 8d4:	71 05       	cpc	r23, r1
 8d6:	61 05       	cpc	r22, r1
 8d8:	08 94       	sec
 8da:	08 95       	ret

000008dc <__fp_zero>:
 8dc:	e8 94       	clt

000008de <__fp_szero>:
 8de:	bb 27       	eor	r27, r27
 8e0:	66 27       	eor	r22, r22
 8e2:	77 27       	eor	r23, r23
 8e4:	cb 01       	movw	r24, r22
 8e6:	97 f9       	bld	r25, 7
 8e8:	08 95       	ret

000008ea <__mulsf3>:
 8ea:	0e 94 88 04 	call	0x910	; 0x910 <__mulsf3x>
 8ee:	0c 94 f9 04 	jmp	0x9f2	; 0x9f2 <__fp_round>
 8f2:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <__fp_pscA>
 8f6:	38 f0       	brcs	.+14     	; 0x906 <__stack+0x7>
 8f8:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <__fp_pscB>
 8fc:	20 f0       	brcs	.+8      	; 0x906 <__stack+0x7>
 8fe:	95 23       	and	r25, r21
 900:	11 f0       	breq	.+4      	; 0x906 <__stack+0x7>
 902:	0c 94 e2 04 	jmp	0x9c4	; 0x9c4 <__fp_inf>
 906:	0c 94 e8 04 	jmp	0x9d0	; 0x9d0 <__fp_nan>
 90a:	11 24       	eor	r1, r1
 90c:	0c 94 6f 04 	jmp	0x8de	; 0x8de <__fp_szero>

00000910 <__mulsf3x>:
 910:	0e 94 4c 04 	call	0x898	; 0x898 <__fp_split3>
 914:	70 f3       	brcs	.-36     	; 0x8f2 <__mulsf3+0x8>

00000916 <__mulsf3_pse>:
 916:	95 9f       	mul	r25, r21
 918:	c1 f3       	breq	.-16     	; 0x90a <__stack+0xb>
 91a:	95 0f       	add	r25, r21
 91c:	50 e0       	ldi	r21, 0x00	; 0
 91e:	55 1f       	adc	r21, r21
 920:	62 9f       	mul	r22, r18
 922:	f0 01       	movw	r30, r0
 924:	72 9f       	mul	r23, r18
 926:	bb 27       	eor	r27, r27
 928:	f0 0d       	add	r31, r0
 92a:	b1 1d       	adc	r27, r1
 92c:	63 9f       	mul	r22, r19
 92e:	aa 27       	eor	r26, r26
 930:	f0 0d       	add	r31, r0
 932:	b1 1d       	adc	r27, r1
 934:	aa 1f       	adc	r26, r26
 936:	64 9f       	mul	r22, r20
 938:	66 27       	eor	r22, r22
 93a:	b0 0d       	add	r27, r0
 93c:	a1 1d       	adc	r26, r1
 93e:	66 1f       	adc	r22, r22
 940:	82 9f       	mul	r24, r18
 942:	22 27       	eor	r18, r18
 944:	b0 0d       	add	r27, r0
 946:	a1 1d       	adc	r26, r1
 948:	62 1f       	adc	r22, r18
 94a:	73 9f       	mul	r23, r19
 94c:	b0 0d       	add	r27, r0
 94e:	a1 1d       	adc	r26, r1
 950:	62 1f       	adc	r22, r18
 952:	83 9f       	mul	r24, r19
 954:	a0 0d       	add	r26, r0
 956:	61 1d       	adc	r22, r1
 958:	22 1f       	adc	r18, r18
 95a:	74 9f       	mul	r23, r20
 95c:	33 27       	eor	r19, r19
 95e:	a0 0d       	add	r26, r0
 960:	61 1d       	adc	r22, r1
 962:	23 1f       	adc	r18, r19
 964:	84 9f       	mul	r24, r20
 966:	60 0d       	add	r22, r0
 968:	21 1d       	adc	r18, r1
 96a:	82 2f       	mov	r24, r18
 96c:	76 2f       	mov	r23, r22
 96e:	6a 2f       	mov	r22, r26
 970:	11 24       	eor	r1, r1
 972:	9f 57       	subi	r25, 0x7F	; 127
 974:	50 40       	sbci	r21, 0x00	; 0
 976:	9a f0       	brmi	.+38     	; 0x99e <__mulsf3_pse+0x88>
 978:	f1 f0       	breq	.+60     	; 0x9b6 <__mulsf3_pse+0xa0>
 97a:	88 23       	and	r24, r24
 97c:	4a f0       	brmi	.+18     	; 0x990 <__mulsf3_pse+0x7a>
 97e:	ee 0f       	add	r30, r30
 980:	ff 1f       	adc	r31, r31
 982:	bb 1f       	adc	r27, r27
 984:	66 1f       	adc	r22, r22
 986:	77 1f       	adc	r23, r23
 988:	88 1f       	adc	r24, r24
 98a:	91 50       	subi	r25, 0x01	; 1
 98c:	50 40       	sbci	r21, 0x00	; 0
 98e:	a9 f7       	brne	.-22     	; 0x97a <__mulsf3_pse+0x64>
 990:	9e 3f       	cpi	r25, 0xFE	; 254
 992:	51 05       	cpc	r21, r1
 994:	80 f0       	brcs	.+32     	; 0x9b6 <__mulsf3_pse+0xa0>
 996:	0c 94 e2 04 	jmp	0x9c4	; 0x9c4 <__fp_inf>
 99a:	0c 94 6f 04 	jmp	0x8de	; 0x8de <__fp_szero>
 99e:	5f 3f       	cpi	r21, 0xFF	; 255
 9a0:	e4 f3       	brlt	.-8      	; 0x99a <__mulsf3_pse+0x84>
 9a2:	98 3e       	cpi	r25, 0xE8	; 232
 9a4:	d4 f3       	brlt	.-12     	; 0x99a <__mulsf3_pse+0x84>
 9a6:	86 95       	lsr	r24
 9a8:	77 95       	ror	r23
 9aa:	67 95       	ror	r22
 9ac:	b7 95       	ror	r27
 9ae:	f7 95       	ror	r31
 9b0:	e7 95       	ror	r30
 9b2:	9f 5f       	subi	r25, 0xFF	; 255
 9b4:	c1 f7       	brne	.-16     	; 0x9a6 <__mulsf3_pse+0x90>
 9b6:	fe 2b       	or	r31, r30
 9b8:	88 0f       	add	r24, r24
 9ba:	91 1d       	adc	r25, r1
 9bc:	96 95       	lsr	r25
 9be:	87 95       	ror	r24
 9c0:	97 f9       	bld	r25, 7
 9c2:	08 95       	ret

000009c4 <__fp_inf>:
 9c4:	97 f9       	bld	r25, 7
 9c6:	9f 67       	ori	r25, 0x7F	; 127
 9c8:	80 e8       	ldi	r24, 0x80	; 128
 9ca:	70 e0       	ldi	r23, 0x00	; 0
 9cc:	60 e0       	ldi	r22, 0x00	; 0
 9ce:	08 95       	ret

000009d0 <__fp_nan>:
 9d0:	9f ef       	ldi	r25, 0xFF	; 255
 9d2:	80 ec       	ldi	r24, 0xC0	; 192
 9d4:	08 95       	ret

000009d6 <__fp_pscA>:
 9d6:	00 24       	eor	r0, r0
 9d8:	0a 94       	dec	r0
 9da:	16 16       	cp	r1, r22
 9dc:	17 06       	cpc	r1, r23
 9de:	18 06       	cpc	r1, r24
 9e0:	09 06       	cpc	r0, r25
 9e2:	08 95       	ret

000009e4 <__fp_pscB>:
 9e4:	00 24       	eor	r0, r0
 9e6:	0a 94       	dec	r0
 9e8:	12 16       	cp	r1, r18
 9ea:	13 06       	cpc	r1, r19
 9ec:	14 06       	cpc	r1, r20
 9ee:	05 06       	cpc	r0, r21
 9f0:	08 95       	ret

000009f2 <__fp_round>:
 9f2:	09 2e       	mov	r0, r25
 9f4:	03 94       	inc	r0
 9f6:	00 0c       	add	r0, r0
 9f8:	11 f4       	brne	.+4      	; 0x9fe <__fp_round+0xc>
 9fa:	88 23       	and	r24, r24
 9fc:	52 f0       	brmi	.+20     	; 0xa12 <__fp_round+0x20>
 9fe:	bb 0f       	add	r27, r27
 a00:	40 f4       	brcc	.+16     	; 0xa12 <__fp_round+0x20>
 a02:	bf 2b       	or	r27, r31
 a04:	11 f4       	brne	.+4      	; 0xa0a <__fp_round+0x18>
 a06:	60 ff       	sbrs	r22, 0
 a08:	04 c0       	rjmp	.+8      	; 0xa12 <__fp_round+0x20>
 a0a:	6f 5f       	subi	r22, 0xFF	; 255
 a0c:	7f 4f       	sbci	r23, 0xFF	; 255
 a0e:	8f 4f       	sbci	r24, 0xFF	; 255
 a10:	9f 4f       	sbci	r25, 0xFF	; 255
 a12:	08 95       	ret

00000a14 <__tablejump2__>:
 a14:	ee 0f       	add	r30, r30
 a16:	ff 1f       	adc	r31, r31
 a18:	05 90       	lpm	r0, Z+
 a1a:	f4 91       	lpm	r31, Z
 a1c:	e0 2d       	mov	r30, r0
 a1e:	09 94       	ijmp

00000a20 <_exit>:
 a20:	f8 94       	cli

00000a22 <__stop_program>:
 a22:	ff cf       	rjmp	.-2      	; 0xa22 <__stop_program>
